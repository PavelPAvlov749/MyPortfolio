"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Native
const os_1 = require("os");
const path_1 = require("path");
const systeminformation_1 = __importDefault(require("systeminformation"));
// Vendor
// @ts-ignore
const image_size_1 = __importDefault(require("image-size"));
/**
 * Get the /bin/ directory from the root of the project
 */
exports.getBinaryDirectory = () => __awaiter(void 0, void 0, void 0, function* () {
    let plat = os_1.platform();
    if (plat === 'linux') {
        const { distro, release, kernel } = yield systeminformation_1.default.osInfo();
        if ((/CentOS/g.test(distro) || /alios7/g.test(kernel)) && (~~parseFloat(release) === 7)) {
            plat = 'centos7';
        }
    }
    return path_1.join(__dirname, '../../../bin/', plat);
});
/**
 * Get a file extension from a file path (without a file basename)
 *
 * @param filepath Input filepath
 */
exports.getFileExtension = (filepath) => path_1.parse(filepath).ext;
/**
 * Get a file basename from a file path (without a file extension)
 *
 * @param filepath Input filepath
 */
exports.getFileName = (filepath) => path_1.basename(filepath, exports.getFileExtension(filepath));
/**
 * Get image size
 *
 * @param filepath Path to image
 */
exports.getImageSize = (filepath) => image_size_1.default(filepath);
/**
 * Get mip map levels based on initial value
 *
 * @param value Initial value
 */
exports.getMipChainLevels = (value) => Math.floor(Math.log2(value)) + 1;
/**
 * Create flags out of custom flags passed in through the --flag parameter
 *
 * @param flags Array of flags to pass to the tool
 */
exports.createFlagsForTool = (flags) => flags.map(flag => `-${flag}`);
/**
 * Split flag name and flag value passed in through the --flag parameter
 *
 * @param flags Array of flags to pass to the tool
 */
exports.splitFlagAndValue = (flags) => [].concat(...flags.map(flag => flag.split(' ')));
//# sourceMappingURL=utilities.js.map