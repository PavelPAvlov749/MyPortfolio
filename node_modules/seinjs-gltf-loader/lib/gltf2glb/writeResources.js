var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var Cesium = require('cesium');
var mime = require('mime');
var addBuffer = require('./addBuffer');
var ForEach = require('./ForEach');
var getImageExtension = require('./getImageExtension');
var mergeBuffers = require('./mergeBuffers');
var removeUnusedElements = require('./removeUnusedElements');
var defaultValue = Cesium.defaultValue;
var defined = Cesium.defined;
var WebGLConstants = Cesium.WebGLConstants;
// .crn (Crunch) is not a supported mime type, so add it
mime.define({ 'image/crn': ['crn'] }, true);
// .glsl shaders are text/plain type
mime.define({ 'text/plain': ['glsl'] }, true);
module.exports = writeResources;
/**
 * Write glTF resources as data uris, buffer views, or files.
 *
 * @param {Object} gltf A javascript object containing a glTF asset.
 * @param {Object} [options] Object with the following properties:
 * @param {String} [options.name] The name of the glTF asset, for writing separate resources.
 * @param {Boolean} [options.separateBuffers=false] Whether to save buffers as separate files.
 * @param {Boolean} [options.separateShaders=false] Whether to save shaders as separate files.
 * @param {Boolean} [options.separateTextures=false] Whether to save images as separate files.
 * @param {Boolean} [options.dataUris=false] Write embedded resources as data uris instead of buffer views.
 * @param {Boolean} [options.dracoOptions.uncompressedFallback=false] If set, add uncompressed fallback versions of the compressed meshes.
 * @param {Object} [options.bufferStorage] When defined, the glTF buffer's underlying Buffer object will be saved here instead of encoded as a data uri or saved as a separate resource.
 * @param {Object} [options.separateResources] When defined, buffers of separate resources will be saved here.
 * @returns {Object} The glTF asset.
 *
 * @private
 */
function writeResources(gltf, options) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    options = defaultValue(options, {});
                    options.separateBuffers = defaultValue(options.separateBuffers, false);
                    options.separateTextures = defaultValue(options.separateTextures, false);
                    options.separateShaders = defaultValue(options.separateShaders, false);
                    options.dataUris = defaultValue(options.dataUris, false);
                    return [4 /*yield*/, ForEach.imageAsync(gltf, function (image, i) {
                            return __awaiter(this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, writeImage(gltf, image, i, options)];
                                        case 1:
                                            _a.sent();
                                            return [4 /*yield*/, ForEach.compressedImageAsync(image, function (compressedImage) {
                                                    return __awaiter(this, void 0, void 0, function () {
                                                        return __generator(this, function (_a) {
                                                            switch (_a.label) {
                                                                case 0: return [4 /*yield*/, writeImage(gltf, compressedImage, i, options)];
                                                                case 1:
                                                                    _a.sent();
                                                                    return [2 /*return*/];
                                                            }
                                                        });
                                                    });
                                                })];
                                        case 2:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            });
                        })];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, ForEach.shaderAsync(gltf, function (shader, i) {
                            return __awaiter(this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, writeShader(gltf, shader, i, options)];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            });
                        })];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, ForEach.audioClipAsync(gltf, function (audioClip, i) {
                            return __awaiter(this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, writeAudio(gltf, audioClip, i, options)];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            });
                        })];
                case 3:
                    _a.sent();
                    // Buffers need to be written last because images and shaders may write to new buffers
                    removeUnusedElements(gltf);
                    mergeBuffers(gltf, options.name);
                    return [4 /*yield*/, ForEach.bufferAsync(gltf, function (buffer, bufferId) {
                            return __awaiter(this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, writeBuffer(gltf, buffer, bufferId, options, true)];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            });
                        })];
                case 4:
                    _a.sent();
                    return [2 /*return*/, gltf];
            }
        });
    });
}
function writeBuffer(gltf, buffer, i, options) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!defined(options.bufferStorage)) return [3 /*break*/, 1];
                    writeBufferStorage(buffer, options);
                    return [3 /*break*/, 3];
                case 1: return [4 /*yield*/, writeResource(gltf, buffer, i, separate, true, '.bin', options)];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3: return [2 /*return*/];
            }
        });
    });
}
function writeBufferStorage(buffer, options) {
    var combinedBuffer = options.bufferStorage.buffer;
    combinedBuffer = defined(combinedBuffer) ? combinedBuffer : Buffer.alloc(0);
    combinedBuffer = Buffer.concat([combinedBuffer, buffer.extras._pipeline.source]);
    options.bufferStorage.buffer = combinedBuffer;
}
function writeImage(gltf, image, i, options) {
    return __awaiter(this, void 0, void 0, function () {
        var extension;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    extension = getImageExtension(image.extras._pipeline.source);
                    return [4 /*yield*/, writeResource(gltf, image, i, options.separateTextures, options.dataUris, extension, options)];
                case 1:
                    _a.sent();
                    if (defined(image.bufferView)) {
                        // Preserve the image mime type when writing to a buffer view
                        image.mimeType = mime.getType(extension);
                    }
                    return [2 /*return*/];
            }
        });
    });
}
function writeAudio(gltf, audioClip, i, options) {
    return __awaiter(this, void 0, void 0, function () {
        var extension, separate;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    extension = audioClip.extras._pipeline.ext;
                    separate = audioClip.isLazy && audioClip.mode === 'Stream';
                    return [4 /*yield*/, writeResource(gltf, audioClip, i, separate, options.dataUris, extension, options)];
                case 1:
                    _a.sent();
                    if (defined(audioClip.bufferView)) {
                        // Preserve the image mime type when writing to a buffer view
                        audioClip.mimeType = mime.getType(extension);
                    }
                    return [2 /*return*/];
            }
        });
    });
}
function writeShader(gltf, shader, i, options) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, writeResource(gltf, shader, i, options.separateShaders, options.dataUris, '.glsl', options)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function writeResource(gltf, object, index, separate, dataUris, extension, options) {
    return __awaiter(this, void 0, void 0, function () {
        var uri, source, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    separate = separate || options.separateCustom(getRelativePath(gltf, object, index, extension, options));
                    uri = object.extras._pipeline.relativePath;
                    source = object.extras._pipeline.source;
                    if (!!separate) return [3 /*break*/, 2];
                    _a = object.extras._pipeline;
                    return [4 /*yield*/, options.prepareNonSeparateResources(uri, source)];
                case 1:
                    _a.source = _b.sent();
                    _b.label = 2;
                case 2:
                    if (!separate) return [3 /*break*/, 4];
                    return [4 /*yield*/, writeFile(gltf, object, index, extension, options)];
                case 3:
                    _b.sent();
                    return [3 /*break*/, 5];
                case 4:
                    if (dataUris) {
                        writeDataUri(object, extension);
                    }
                    else {
                        writeBufferView(gltf, object);
                    }
                    _b.label = 5;
                case 5: return [2 /*return*/];
            }
        });
    });
}
function writeDataUri(object, extension) {
    delete object.bufferView;
    var source = object.extras._pipeline.source;
    var mimeType = mime.getType(extension);
    object.uri = 'data:' + mimeType + ';base64,' + source.toString('base64');
}
function writeBufferView(gltf, object) {
    delete object.uri;
    var source = object.extras._pipeline.source;
    if (typeof source === 'string') {
        source = Buffer.from(source);
    }
    object.bufferView = addBuffer(gltf, source);
}
function getProgram(gltf, shaderIndex) {
    return ForEach.program(gltf, function (program, index) {
        if (program.fragmentShader === shaderIndex || program.vertexShader === shaderIndex) {
            return {
                program: program,
                index: index
            };
        }
    });
}
function getName(gltf, object, index, extension, options) {
    var gltfName = options.name;
    var objectName = object.name;
    if (defined(objectName)) {
        return objectName;
    }
    else if (extension === '.bin') {
        if (defined(gltfName)) {
            return gltfName + index;
        }
        return 'buffer' + index;
    }
    else if (extension === '.glsl') {
        var programInfo = getProgram(gltf, index);
        var program = programInfo.program;
        var programIndex = programInfo.index;
        var programName = program.name;
        var shaderType = object.type === WebGLConstants.FRAGMENT_SHADER ? 'FS' : 'VS';
        if (defined(programName)) {
            return programName + shaderType;
        }
        else if (defined(gltfName)) {
            return gltfName + shaderType + programIndex;
        }
        return shaderType.toLowerCase() + programIndex;
    }
    // Otherwise is an image
    if (defined(gltfName)) {
        return gltfName + index;
    }
    return 'image' + index;
}
function getRelativePath(gltf, object, index, extension, options) {
    var pipelineExtras = object.extras._pipeline;
    var relativePath = pipelineExtras.relativePath;
    if (defined(relativePath)) {
        return relativePath.replace(/\\/g, '/');
    }
    var name = getName(gltf, object, index, extension, options);
    relativePath = name + extension;
    // Check if a file of the same name already exists, and if so, append a number
    var number = 1;
    while (defined(options.separateResources[relativePath])) {
        relativePath = name + '_' + number + extension;
    }
    return relativePath;
}
function writeFile(gltf, object, index, extension, options) {
    return __awaiter(this, void 0, void 0, function () {
        var source, relativePath, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    delete object.bufferView;
                    source = object.extras._pipeline.source;
                    relativePath = getRelativePath(gltf, object, index, extension, options);
                    _a = object;
                    return [4 /*yield*/, options.prepareSeparateResource(relativePath, source)];
                case 1:
                    _a.uri = _b.sent();
                    if (defined(options.separateResources)) {
                        options.separateResources[object.uri] = { object: object, source: source };
                    }
                    return [2 /*return*/];
            }
        });
    });
}
